# Отчет по преддипломной практике

# Построение предиката пути при символьном выполнении
Папазьян Е.Ю.

## Метод символьного выполнения
Метод подробно описан в статье [1].
Основная идея метода заключается в том, что вместо конкретного исполнения программы
производится так называемое _символьное выполнение_, при котором переменные программы
(или значения данных в памяти) не принимают каких-либо конкретных значений, а
представляются в символьной форме, выраженной через символьные переменные,
обозначающие входы программы.

Состояние выполнения включает в себя символьные значения всех переменных и точку
в программе, а также **предикат пути**, который является булевым выражением над
символьными входами программы и представляет собой условие достижения данной точки
программы.
Этот предикат задается пользователем в начале исполнения (в вырожденном случае - true)
и изменяется в дальнейшем при переходе по управляющим конструкциям в программе.
Кроме того, в некоторых методах, основанных на символьном выполнении,
пользователю предоставляется возможность изменять его в процессе выполнения
для выбора интересующих его конкретных веток потока управления.

Данный метод может быть использован для автоматизации обнаружения ошибок в программе
и автоматической генерации эксплойтов, как описано в [2], [3], и [4].

## SMT-решатели
При переходе по управляющим конструкциям в программе в процессе символьного выполнения
приходится разрешать вопрос о том, является ли условие, по которому делается условный
переход, или его отрицание логическим следствием предиката пути.
Для решения этой задачи используются **SMT-решатели**.

_Задача SMT (Satisfiability Modulo Theories)_ - задача разрешимости набора логических формул по отношению к
набору _теорий_, описанных на языке логики первого порядка с равенством.

_SMT-решатель_ - программа, получающая на вход задачу SMT в виде набора
логических формул и возвращающая набор значений свободных переменных, который
удовлетворяет всем заданным формулам, если такой существует, или сигнал о
невыполнимости в противном случае.

## Промежуточное представление
Работа будет выполняться на основе промежуточного представления
Pivot 2 [5].

### Компоненты промежуточного представления
**Адресные пространства** делятся на _локальные_ и _удаленные_.
Удаленные адресные пространства отличаются от локальных тем, что не гарантируют
какого-либо конкретного поведения при доступе и, кроме того, доступ к ним может
закончиться ошибкой

**Операции** являются наиболее мелкой единицей задания операционной семантики кода.
Операция принимает на вход набор битовых векторов и возвращает другой набор
битовых векторов на выходе.

**Временные переменные**: являются битовыми векторами различной длины и находятся в 
форме статического единичного присваивания.
Набор временных переменных с последовательными номерами образует *группу*.

**Оператор** - неделимое действие с точки зрения промежуточного представления.
Набор операторов фиксирован и состоит из операторов, действующих над временными
переменными и операторов, загружающих и записывающих данные в локальные и удаленные
адресные пространства

**Базовый блок** - неразрывная с точки зрения управления последовательность операторов.
Блоки соединяются ребрами, с которыми ассоциируются управляющие переменные, а также
выходные группы переменных, которые при переходе по ребру записываются
во входную группу следующего блока.

**Фрагмент** - граф, состоящий из базовых блоков, с единственным входом
и единственным выходом. Фрагмент может иметь входную группу переменных, которая
будет подаваться ему при вызове и записываться во входную группу блока,
являющегося входом этого фрагмента.

Так как в данном представлении все данные представляются в виде битовых векторов
фиксированного размера, то будет использоваться SMT-теория с одноименным названием.
Кроме того, для представления адресных пространств понадобиться использовать
теорию массивов.

## Список литературы
[1] King J. C. Symbolic execution and program testing
//Communications of the ACM. – 1976. – Т. 19. – №. 7. – С. 385-394.  
[2] Cha S. K. et al. Unleashing mayhem on binary code
//2012 IEEE Symposium on Security and Privacy. – IEEE, 2012. – С. 380-394.  
[3] Avgerinos T. et al. AEG: Automatic exploit generation. – 2011.  
[4] Brumley D. et al. Automatic patch-based exploit generation is possible:
Techniques and implications
//2008 IEEE Symposium on Security and Privacy (sp 2008). – IEEE, 2008. – С. 143-157.  
[5] Pivot 2 //TODO: реквизиты  
