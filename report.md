# Отчет по преддипломной практике

# Построение предиката пути при символьном выполнении
Папазьян Е.Ю.

## Метод символьного выполнения
Метод подробно описан в статье [1].
Основная идея метода заключается в том, что вместо конкретного исполнения программы
производится так называемое _символьное выполнение_, при котором переменные программы
(или значения данных в памяти) не принимают каких-либо конкретных значений, а
представляются в символьной форме, выраженной через символьные переменные,
обозначающие входы программы.

Состояние выполнения включает в себя символьные значения всех переменных и точку
в программе, а также **предикат пути**, который является булевым выражением над
символьными входами программы и представляет собой условие достижения данной точки
программы.
Этот предикат задается пользователем в начале исполнения (в вырожденном случае - true)
и изменяется в дальнейшем при переходе по управляющим конструкциям в программе.
Кроме того, в некоторых методах, основанных на символьном выполнении,
пользователю предоставляется возможность изменять его в процессе выполнения
для выбора интересующих его конкретных веток потока управления.

Данный метод может быть использован для автоматизации обнаружения ошибок в программе
и автоматической генерации эксплойтов, как описано в [2], [3], и [4].

## SMT
При переходе по управляющим конструкциям в программе в процессе символьного выполнения
приходится разрешать вопрос о том, является ли условие, по которому делается условный
переход, или его отрицание логическим следствием предиката пути.
Для решения этой задачи используются **SMT-решатели**.

_Задача SMT (Satisfiability Modulo Theories)_ - задача разрешимости набора логических формул по отношению к
набору _теорий_, описанных на языке логики первого порядка с равенством.
Примерами используемых в задачах SMT теорий являются:

* Теория целых чисел
* Теория действительных чисел
* Теория битовых векторов фиксированного размера
* Теория массивов

_SMT-решатель_ - программа, получающая на вход задачу SMT в виде набора
логических формул и возвращающая набор значений свободных переменных, который
удовлетворяет всем заданным формулам, если такой существует, или сигнал о
невыполнимости в противном случае.

Особое внимание нужно уделить теории массивов. Работа с массивами происходит
с помощью двух функций - select и store. Первая возвращает элемент массива по
индексу, вторая - по массиву, индексу и произвольному значению
возвращает новый массив, который отличается от входного только тем, что у него
по указанному индексу находится указанный элемент

## Промежуточное представление
Работа будет выполняться на основе промежуточного представления
Pivot 2 [5].

### Компоненты промежуточного представления
**Адресные пространства** делятся на _локальные_ и _удаленные_.
Удаленные адресные пространства отличаются от локальных тем, что не гарантируют
какого-либо конкретного поведения при доступе и, кроме того, доступ к ним может
закончиться ошибкой

**Операции** являются наиболее мелкой единицей задания операционной семантики кода.
Операция принимает на вход набор битовых векторов и возвращает другой набор
битовых векторов на выходе.

**Временные переменные**: являются битовыми векторами различной длины и находятся в 
форме статического единичного присваивания.
Набор временных переменных с последовательными номерами образует *группу*.

**Оператор** - неделимое действие с точки зрения промежуточного представления.
Набор операторов фиксирован и состоит из операторов, выполняющих преобразования
над временными переменными,
операторов, загружающих и записывающих данные в локальные и удаленные
адресные пространства, оператора, выполняющую указанную _операцию_, и оператора,
отвечающего за передачу управления на указанный фрагмент.

**Базовый блок** - неразрывная с точки зрения управления последовательность операторов.
Блоки соединяются ребрами, с которыми ассоциируются управляющие переменные, а также
выходные группы переменных, которые при переходе по ребру записываются
во входную группу следующего блока.

**Фрагмент** - граф, состоящий из базовых блоков, с единственным входом
и единственным выходом. Фрагмент может иметь входную группу переменных, которая
будет подаваться ему при вызове и записываться во входную группу блока,
являющегося входом этого фрагмента.

Так как в данном представлении все данные представляются в виде битовых векторов
фиксированного размера, то будет использоваться SMT-теория с одноименным названием.
Кроме того, для представления адресных пространств понадобиться использовать
теорию массивов.

## Предлагаемое решение
Программа на вход получает путь, который на данный момент представляет из себя
вектор базовых блоков, и начальное выражение для предиката пути,
а на выходе выдает предикат пути в его конце.

Так как в данном промежуточном представлении все временные переменные находятся
в форме статического единичного присваивания, то их можно хранить в виде массива
SMT-выражений.
Далее везде под значением временной переменной будет пониматься соответствующее ей
выражение, хранящееся в этом массиве.
При переходе из одного базового блока в другой, новый массив временных переменных
будет результатом извлечения из предыдущего массива группы переменных, являющихся
выходной группой предыдущего блока.

Выполнение операторов, напрямую работающих только с временными переменными,
представляет собой построение выражений, cоответствующих семантике рассматриваемого
оператора, с помощью SMT-функций преобразования битовых векторов
и запись этого выражения или выражений
в выходную переменную или группу переменных.

Судя по проведенным тестам, SMT-решатели не имеют трудностей при работе с массивами
большого размера, поэтому каждое локальное адресное пространства может быть
представлено одним большим массивом битовых векторов длины 8.
В процессе выполнения будет храниться таблица, сопостовляющая каждому
адресному пространству выражение-массив, которое его описывает.
Тогда при выполнении загрузки временной переменной
из локального адресного пространства запись этой переменной в таблице
перезаписывается выражением, соответствующим элементу массива, 
расположенному по указаному адресу,
а при выполнении записи переменной - массив перезаписывается
новым массивом с указанной переменной, записанной по указанному адресу.

В операторах записи и загрузки из памяти допускается задание произвольного размера
в битах читаемого или записываемого значения, вследстие чего возникает проблема
правильного построения выражения, точно определяющего оперируемую область
адресного пространства в используемом массиве битовых векторов.
В связи с этим используются соотвествующие функции
SMT-теории битовых векторов фиксированного размера - функции
извлечения и конкатенации битовых векторов, которые
применяются на соседних в массиве битовых векторах (байтах) для построения
требуемого выражения.

При переходе по ребру выполняется проверка того, является ли значение управляющей
переменной (или ее отрицания, если переход осуществляется по false ребру) логическим
следствием нынешнего предиката пути. Для этого конструируется соответствующее
SMT-выражение (импликация первого и второго выражений) и отправляется в SMT-решатель.
Если является, то предикат пути остается неизменным и выполнение переходит на
следующий базовый блок, иначе к предикату пути добавляется конъюнкция с
выражением

## Нерешенные проблемы
В то время как локальные адресные пространства можно реализовать простыми массивами
битовых векторов, удаленные адресные пространства оказались несколько сложнее ввиду 
их особого поведения при чтении и записи. При их реализации в данной программе
придется использовать более сложные объекты, чем массивы битовых векторов.

Не реализована также обработка оператора, передающего управление на указанный фрагмент,
так как это требует более сложного
представления пути в программе. Предстоит решить вопросы,
являются ли вызываемые внутри пути фрагменты его частью,
может ли путь содержать возвращения из фрагмента
и т.д.

## Список литературы
[1] King J. C. Symbolic execution and program testing
//Communications of the ACM. – 1976. – Т. 19. – №. 7. – С. 385-394.  
[2] Cha S. K. et al. Unleashing mayhem on binary code
//2012 IEEE Symposium on Security and Privacy. – IEEE, 2012. – С. 380-394.  
[3] Avgerinos T. et al. AEG: Automatic exploit generation. – 2011.  
[4] Brumley D. et al. Automatic patch-based exploit generation is possible:
Techniques and implications
//2008 IEEE Symposium on Security and Privacy (sp 2008). – IEEE, 2008. – С. 143-157.  
[5] Pivot 2 //TODO: реквизиты  
